--!strict

local ConnectUtil = require(script.Parent.ConnectUtil)


local module = {connectionsKey = 'resumeAfterConnections',}

--[[
    @description
    Resumes all provided objects (e.g., tweens, animations) and yields the coroutine until they are complete.
    The `connections` table indexes `resumeAfterConnections`, which stores the active resumption objects.
  
    @params
    - connections: {[any]: any} — A table that tracks `resumeAfterConnections` for the resumed objects.
    - objectsToResume: {[any]: any} — A list of objects to be resumed.

    @notes
    - Automatically unpacks `objectsToResume` and resumes them using `ConnectUtil.resumeAfterAll`.
    - Yields until all objects finish resuming.
    - `objectsToResume` is intentionally NOT stored in the given `connections` table to prevent accidental destruction during cleanup.
]]
function module.all(objectsToResume: {any}, connections: {[any]: any}, dontYield: true?)
	
	-- Adds connections generated by `resumeAfterAll` to a tracked table under a specific key 
	-- so they can be cleared later down the line 
	-- by the developer.
	
	if not connections[module.connectionsKey] then
		connections[module.connectionsKey] = {}
	end
	
	table.insert(connections[module.connectionsKey], {ConnectUtil.resumeAfterAll(unpack(objectsToResume))})
	if not dontYield then
		coroutine.yield()
	end
end



--[[
    @description
    Resumes all provided objects (e.g., tweens, animations) and yields the coroutine until the first completes.
    The `connections` table indexes `resumeAfterConnections`, which stores the active resumption objects.
  
    @params
    - connections: {[any]: any} — A table that tracks `resumeAfterConnections` for the resumed objects.
    - objectsToResume: {[any]: any} — A list of objects to be resumed.

    @notes
    - Automatically unpacks `objectsToResume` and resumes them using `ConnectUtil.resumeAfterAll`.
    - Yields until all objects finish resuming.
    - `objectsToResume` is intentionally NOT stored in the given `connections` table to prevent accidental destruction during cleanup.
]]
function module.first(connections: {[any]: any}, objectsToResume: {any}, dontYield: true?)
	-- Adds connections generated by `resumeAfterAll` to a tracked table under a specific key.  
	-- Ensures the connections table exists for the key, initializing it if necessary.  
	-- This design intentionally avoids directly calling empty() or clean here to prevent  
	-- recursion, as doing so here could interfere with the current call chain. Instead,  
	-- the connections are collected so they can be cleared later down the line 
	-- by the developer.
	if not connections[module.connectionsKey] then
		connections[module.connectionsKey] = {}
	end

	table.insert(connections[module.connectionsKey], {ConnectUtil.resumeAfterFirst(unpack(objectsToResume))})
	if not dontYield then
		coroutine.yield()
	end
end

--[[
    A lighter alternative to `resumeAfter.all` or `resumeAfter.first` when you just need to yield 
    the current thread until a specific condition is met, without wiring into resumption signals 
    or connection tracking. Simply polls the provided `condition` function until it returns a non-nil value 
    or the timeout expires.
]]

function module.condition(condition: () -> ...any, timeout: number?): true?
	local elapsed = 0
	local limit = timeout or 5

	while elapsed < limit do
		local results = { condition() }
		if results[1] then
			return table.unpack(results)
		end
		local dt = task.wait()
		elapsed += dt
	end

	return 
end



return module